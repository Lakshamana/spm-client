<template>
  <div class="container is-fullwidth">
    <div class="columns is-centered">
      <div class="column is-12">
        <table class="table">
          <tr>
            <td>
              <div id="toolbar" ref="toolbar" />
            </td>
          </tr>
          <tr>
            <td id="graphContainer" ref="graphContainer" valign="top">
              <div id="graph">
                <center id="splash" ref="splash">
                  <img src="../assets/loading.gif" />
                </center>
              </div>
              <textarea id="xml" ref="xml"></textarea>
            </td>
          </tr>
        </table>

        <span class="source-ipt">
          <input id="source" ref="source" type="checkbox" />Source
        </span>
      </div>
    </div>
  </div>
</template>

<script>
import mxGraphFactory from 'mxgraph-lakshamana'
import { errorHandler } from './mixins/errorHandler'
import { getXml } from '@/util/xml'

const mx = new mxGraphFactory()

const endpoints = {
  normal: 'normals',
  decomposed: 'decomposeds',
  reqagent: 'req-agents',
  reqworkgroup: 'req-work-groups',
  artifact: 'artifacts',
  joincon: 'join-cons',
  artifactcon: 'artifact-cons',
  sequence: 'sequences',
  branchcon: 'branch-cons'
}

const edgeTypes = {
  'normal,normal': 'sequence',
  'decomposed,decomposed': 'sequence',
  'normal,decomposed': 'sequence',
  artifact: 'artifactcon',
  joincon: 'connector',
  branchcon: 'connector',
  reqagent: 'connector',
  reqworkgroup: 'connector'
}

const genericTypes = {
  activity: ['normal', 'decomposed'],
  multipleConnection: ['joincon', 'branchcon'],
  simpleConnection: ['sequence', 'feedback']
}

const args = {
  sequence: ['ident', 'fromActivity', 'toActivity'],
  artifactcon: ['ident', 'theArtifact', 'toActivities', 'fromActivities'],
  normal: [
    'ident',
    ['toJoinCons', 'joincon', 'list'],
    ['fromJoinCons', 'joincon', 'list'],
    ['fromBranchANDCons', 'branchcon', 'list'],
    ['toBranchCons', 'branchcon', 'list']
  ],
  decomposed: [
    'ident',
    ['toJoinCons', 'joincon', 'list'],
    ['fromJoinCons', 'joincon', 'list'],
    ['fromBranchANDCons', 'branchcon', 'list'],
    ['toBranchCons', 'branchcon', 'list']
  ],
  reqagent: ['theNormal'],
  reqworkgroup: ['theNormal'],
  artifact: ['ident'],
  // Para criação, basta usar ident
  joincon: [
    'ident',
    ['fromMultipleCons', 'multipleConnection', 'list'],
    ['fromActivities', 'activity', 'list'],
    ['toActivity', 'activity'],
    ['toMultipleCon', 'multipleConnection']
  ],
  branchcon: [
    'ident',
    ['fromActivity', 'activity'],
    ['fromMultipleConnection', 'multipleConnection'],
    ['toActivities', 'activity', 'list'],
    ['toMultipleCons', 'multipleConnection', 'list']
  ]
}

export default {
  name: 'Editor',

  mixins: [errorHandler],

  props: {
    processModelId: {
      type: Number,
      default: 0
    }
  },

  data() {
    return {
      editor: undefined,
      validatees: {
        normal: {
          targets: ['normal', 'decomposed', 'artifact', 'joincon', 'branchcon'],
          constraints: {
            outgoingTo: {
              normal: 1,
              decomposed: 2
            },
            incomingFrom: {
              normal: 1,
              decomposed: 2
            }
          }
        },
        decomposed: {
          targets: ['normal', 'decomposed', 'artifact', 'joincon', 'branchcon']
        },
        agent: {
          targets: ['normal', 'decomposed']
        },
        workgroup: {
          targets: ['normal', 'decomposed']
        },
        artifact: {
          targets: ['normal', 'decomposed']
        },
        join: {
          targets: ['normal', 'decomposed', 'joincon', 'branchcon']
        },
        branch: {
          targets: ['normal', 'decomposed', 'joincon', 'branchcon']
        }
      },
      validators: {
        targets: this.validateTargets,
        constraints: this.validateConstraints
      },
      targetSkip: ['targets'],
      sourceSkip: []
    }
  },

  watch: {
    processModelId(val) {
      console.log('New Value:', val)

      // if our graph is not empty
      const cells = Object.values(this.editor.graph.model.cells)
      if (cells.length > 2) {
        console.log('updating graph state...')
        // remove first 2 cells
        this.syncGraphState(cells.slice(2))
      }
    }
  },

  created() {
    this.$addToWindow('mxGeometry', mx.mxGeometry)
    this.$addToWindow('mxGraph', mx.mxGraph)
    this.$addToWindow('mxCodec', mx.mxCodec)
    this.$addToWindow('mxGraphModel', mx.mxGraphModel)
    this.$addToWindow('mxUtils', mx.mxUtils)
    this.$addToWindow('mxClient', mx.mxClient)
    this.$addToWindow('mxEvent', mx.mxEvent)
    this.$addToWindow('mxEffects', mx.mxEffects)
    this.$addToWindow('mxEditor', mx.mxEditor)
    this.$addToWindow('mxObjectCodec', mx.mxObjectCodec)
    this.$addToWindow('mxPanningManager', mx.mxPanningManager)
    this.$addToWindow('mxVertexHandler', mx.mxVertexHandler)
    this.$addToWindow('mxGraphHandler', mx.mxGraphHandler)
    this.$addToWindow('mxGuide', mx.mxGuide)
    this.$addToWindow('mxEdgeHandler', mx.mxEdgeHandler)
    this.$addToWindow('mxConnectionHandler', mx.mxConnectionHandler)
    this.$addToWindow('mxXmlRequest', mx.mxXmlRequest)
    this.$addToWindow('mxImageExport', mx.mxImageExport)
    this.$addToWindow('mxSvgCanvas2D', mx.mxSvgCanvas2D)
    this.$addToWindow('mxConstants', mx.mxConstants)
    this.$addToWindow('mxXmlCanvas2D', mx.mxXmlCanvas2D)
    this.$addToWindow('mxImage', mx.mxImage)
    this.$addToWindow('mxResources', mx.mxResources)
    this.$addToWindow('mxStylesheet', mx.mxStylesheet)
    this.$addToWindow('mxDefaultToolbar', mx.mxDefaultToolbar)
    this.$addToWindow('mxToolbar', mx.mxToolbar)
    this.$addToWindow('mxMultiplicity', mx.mxMultiplicity)
    this.$addToWindow('onInit', this.onInit)
  },

  mounted() {
    this.editor = this.createEditor(getXml())
  },

  beforeDestroy() {
    window.onbeforeunload = () => mx.mxResources.get('changesLost')
  },

  methods: {
    syncGraphState(cells) {
      console.log(cells)
    },

    async getCoordinateResponse(cell) {
      const { x, y } = cell.geometry
      await this.$axios.post('/api/easy-modeling', {
        processId: this.processModelId,
        referedObjectId: this.getEntityId(cell.id),
        nodeType: cell.value.nodeName,
        x,
        y
      })
    },

    setEdgeType(edge) {
      const ends =
        edge.source.getAttribute('type') +
        ',' +
        edge.target.getAttribute('type')
      const endsInv =
        edge.target.getAttribute('type') +
        ',' +
        edge.source.getAttribute('type')
      for (const end in edgeTypes) {
        if (ends === end || endsInv === end || ends.includes(end)) {
          console.log('set type:', edgeTypes[end])
          edge.setAttribute('type', edgeTypes[end])
        }
      }
    },

    entityArguments(cell) {
      const cellType = cell.getAttribute('type')
      let payload = {}
      if (cell.edge) {
        const ident = cell.source.id + 'to' + cell.target.id
        if (cellType === 'sequence') {
          payload = { ident }
          payload.fromActivity = {
            id: this.getEntityId(cell.source.id)
          }
          payload.toActivity = {
            id: this.getEntityId(cell.target.id)
          }
        } else if (cellType === 'artifactcon') {
          payload = { ident }
          const artifactId =
            cell.source.getAttribute('type') === 'artifact'
              ? cell.source.id
              : cell.target.id
          if (artifactId === cell.source.id) {
            payload.toActivities = {
              id: cell.target.id
            }
          } else {
            payload.fromActivities = {
              id: cell.source.id
            }
          }
        } else if (cellType === 'connector') {
          console.log('celltype:', cellType)
          for (const sideNode of ['source']) {
            console.log('sideNode:', sideNode)
            const type = cell[sideNode].getAttribute('type')
            const params = args[type]
            console.log(params)
            const prefix = sideNode === 'source' ? 'to' : 'from'
            const other = sideNode === 'source' ? 'target' : 'source'
            const otherType = cell[other].getAttribute('type')
            for (const p of params) {
              console.log('param:', p)
              if (p === 'ident') {
                payload.ident = cell[sideNode].getAttribute('label')
                continue
              }
              if (typeof p === 'string') {
                payload[p] = {
                  id: this.getEntityId(cell[other].id)
                }
              } else {
                // param p will be an array
                const [argname, typeKey, isList] = p
                console.log(
                  'argname=' + argname + '; genericTypeKey=' + typeKey
                )
                if (
                  ((genericTypes[typeKey] &&
                    genericTypes[typeKey].includes(otherType)) ||
                    typeKey === otherType) &&
                  argname.startsWith(prefix)
                ) {
                  const sendObj = {
                    id: this.getEntityId(cell[other].id)
                  }
                  payload[argname] = isList ? [sendObj] : sendObj
                }
              }
            }
          }
        }
      } else if (!['reqagent', 'reqworkgroup'].includes(cellType)) {
        const ident = prompt(`Type ${cellType}'s ident`)
        cell.setAttribute('label', ident)
        console.log('vertex type:', cellType)
        payload = { ident }
        if (
          cellType !== 'artifact' &&
          !genericTypes.multipleConnection.includes(cellType)
        ) {
          payload.theProcessModel = {
            id: this.processModelId
          }
        }
      }
      return payload
    },

    setCellEntity(cell, entityId) {
      cell.setId(cell.value.nodeName + '#' + entityId)
    },

    getEntityId(cellId) {
      return +cellId.split('#')[1]
    },

    setXmlValue(xml) {
      const textNode = this.$refs.xml
      if (xml !== textNode.value) {
        textNode.value = xml
        const doc = mx.mxUtils.parseXml(textNode.value)
        const dec = new mx.mxCodec(doc)
        dec.decode(doc.documentElement, this.editor.graph.getModel())
      }
    },

    createEditor(config) {
      let editor = null

      const hideSplash = () => {
        const splash = this.$refs.splash

        if (splash != null) {
          try {
            mx.mxEvent.release(splash)
            mx.mxEffects.fadeOut(splash, 500, true)
          } catch (e) {
            this.loading = false
          }
        }
      }

      try {
        if (!mx.mxClient.isBrowserSupported()) {
          mx.mxUtils.error('Browser is not supported!', 200, false)
        } else {
          mx.mxObjectCodec.allowEval = true

          mx.mxEditor.prototype.getToolbar = function() {
            return this.toolbar.toolbar
          }

          const node = mx.mxUtils.parseXml(config).documentElement
          editor = new mx.mxEditor(node)
          mx.mxObjectCodec.allowEval = false

          editor.graph.createPanningManager = function() {
            const pm = new mx.mxPanningManager(this)
            pm.border = 30
            return pm
          }
          editor.graph.allowAutoPanning = false
          editor.graph.timerAutoScroll = true
          editor.validation = true

          editor.graph.multiplicities.push(
            new mx.mxMultiplicity(
              true,
              'join',
              null,
              null,
              0,
              1,
              ['normal', 'decomposed', 'join', 'branch'],
              'Join must have at max 1 source node!',
              null
            ),
            new mx.mxMultiplicity(
              false,
              'branch',
              null,
              null,
              0,
              1,
              ['normal', 'decomposed', 'join', 'branch'],
              'Branch must have at max 1 target node!',
              null
            )
          )

          const funct = sender => {
            document.title =
              process.env.npm_package_name + ' - ' + sender.getTitle()
          }

          editor.addListener(mx.mxEvent.OPEN, funct)

          funct(editor)

          editor.setStatus('mxGraph ' + mx.mxClient.VERSION)

          hideSplash()
        }
      } catch (e) {
        hideSplash()

        mx.mxUtils.alert('Cannot start application: ' + e.message)
        throw e
      }
      return editor
    },

    onInit(editor) {
      mx.mxVertexHandler.prototype.rotationEnabled = false

      mx.mxGraphHandler.prototype.guidesEnabled = true

      mx.mxGuide.prototype.isEnabledForEvent = evt => {
        return !mx.mxEvent.isAltDown(evt)
      }

      mx.mxEdgeHandler.prototype.snapToTerminals = true

      mx.mxGraph.prototype.setCellsResizable(false)

      const IMG_PATH = process.env.MXIMGPATH
      mx.mxConnectionHandler.prototype.connectImage = new mx.mxImage(
        `${IMG_PATH}/connector.gif`,
        16,
        16
      )

      editor.graph.setConnectable(true)

      const title = document.getElementById('title')

      if (title != null) {
        const f = sender => {
          title.innerHTML = 'mxDraw - ' + sender.getTitle()
        }
        f(editor)
      }

      editor.graph.connectionHandler.addListener(
        mx.mxEvent.CONNECT,
        (_, evt) => {
          const edge = evt.getProperty('cell')
          try {
            this.validateConnection(edge)
          } catch (e) {
            alert(`Can't create connection: "${e}"`)
            editor.graph.removeCells([edge], true)
          }
          editor.graph.validateGraph()
          this.setEdgeType(edge)
          const edgeType = edge.getAttribute('type')
          const endpoint =
            edgeType === 'connector'
              ? endpoints[edge.source.getAttribute('type')]
              : endpoints[edgeType]
          const params = {
            id: this.getEntityId(edge.source.id),
            ...this.entityArguments(edge)
          }
          console.log(params)
          this.$axios
            .put(`/api/${endpoint}`, params)
            .then(async ({ data }) => {
              console.log(await data)
              this.setCellEntity(edge, await data.id)
            })
            .catch(err => {
              this.handle(err)
              editor.graph.removeCells([edge], false)
            })
            .finally(() => mx.mxEvent.consume(evt))
        }
      )

      editor.addListener(mx.mxEvent.BEFORE_ADD_VERTEX, (_, evt) => {
        const vtx = evt.getProperty('vertex')
        console.log(vtx)
        const vtxType = vtx.getAttribute('type')
        console.log(vtxType, endpoints[vtxType])
        this.$axios
          .post(`/api/${endpoints[vtxType]}`, this.entityArguments(vtx))
          .then(async ({ data }) => {
            console.log(await data)
            this.setCellEntity(vtx, await data.id)
            await this.getCoordinateResponse(vtx)
          })
          .catch(err => {
            this.handle(err)
            editor.graph.removeCells([vtx], false)
          })
          .finally(() => mx.mxEvent.consume(evt))
      })

      editor.graph.addListener(mx.mxEvent.MOVE_CELLS, (sender, evt) => {
        const cell = editor.graph.getSelectionCell()
        let { x, y } = editor.graph.view.getState(cell).origin
        const dx = evt.getProperty('dx')
        const dy = evt.getProperty('dy')
        x += dx
        y += dy
        if (x < 0) {
          cell.geometry.x = 0
        }
        if (y < 0) {
          cell.geometry.y = 0
        }
        mx.mxEvent.consume(evt)
      })

      const textNode = this.$refs.xml
      const graphNode = editor.graph.container
      const sourceInput = this.$refs.source
      sourceInput.checked = false

      const funct = editor => {
        if (sourceInput.checked) {
          graphNode.style.display = 'none'
          textNode.style.display = 'inline'

          const enc = new mx.mxCodec()
          const node = enc.encode(editor.graph.getModel())

          textNode.value = mx.mxUtils.getPrettyXml(node)
          textNode.originalValue = textNode.value
          textNode.focus()
        } else {
          graphNode.style.display = ''

          if (textNode.value !== textNode.originalValue) {
            const doc = mx.mxUtils.parseXml(textNode.value)
            const dec = new mx.mxCodec(doc)
            dec.decode(doc.documentElement, editor.graph.getModel())
          }

          textNode.originalValue = null

          if (mx.mxClient.IS_IE) {
            mx.mxUtils.clearSelection()
          }

          textNode.style.display = 'none'

          editor.graph.container.focus()
        }
      }

      editor.addAction('switchView', funct)

      mx.mxEvent.addListener(sourceInput, 'click', () => {
        editor.execute('switchView')
      })

      if (editor.urlImage != null) {
        const exportImage = editor => {
          const graph = editor.graph
          const scale = graph.view.scale
          const bounds = graph.getGraphBounds()

          const xmlDoc = mx.mxUtils.createXmlDocument()
          const root = xmlDoc.createElement('output')
          xmlDoc.appendChild(root)

          const xmlCanvas = new mx.mxXmlCanvas2D(root)
          xmlCanvas.translate(
            Math.floor(1 / scale - bounds.x),
            Math.floor(1 / scale - bounds.y)
          )
          xmlCanvas.scale(scale)

          const imgExport = new mx.mxImageExport()
          imgExport.drawState(
            graph.getView().getState(graph.model.root),
            xmlCanvas
          )

          const w = Math.ceil(bounds.width * scale + 2)
          const h = Math.ceil(bounds.height * scale + 2)
          const xml = mx.mxUtils.getXml(root)

          if (w > 0 && h > 0) {
            const name = 'export.png'
            const format = 'png'
            const bg = '&bg=#FFFFFF'

            new mx.mxXmlRequest(
              editor.urlImage,
              'filename=' +
                name +
                '&format=' +
                format +
                bg +
                '&w=' +
                w +
                '&h=' +
                h +
                '&xml=' +
                encodeURIComponent(xml)
            ).simulate(document, '_blank')
          }
        }
        editor.addAction('exportImage', exportImage)
      }
    },

    validateConnection(edge) {
      const roots = ['source', 'target']
      for (const rt of roots) {
        const t = this.getVertexType(edge[rt])
        const rules = this.validatees[t]
        for (const r in rules) {
          if (this[`${rt}Skip`].includes(r)) {
            continue
          }
          const validateFn = this.validators[r]
          try {
            validateFn(edge[rt], edge, rules[r])
          } catch (e) {
            throw e
          }
        }
      }
    },

    getVertexType(vertex) {
      return vertex.value.nodeName.toLowerCase()
    },

    validateTargets(vertex, edge, targets) {
      const isSrc = mx.mxUtils.equalEntries(vertex, edge.source)
      const other = isSrc ? 'target' : 'source'
      const targetType = this.getVertexType(edge[other])
      if (!targets.includes(targetType)) {
        throw new Error(`Invalid type ${targetType}`)
      }
    },

    validateConstraints(vertex, edge, allMult) {
      if (Object.keys(allMult).length) {
        const isSrc = mx.mxUtils.equalEntries(vertex, edge.source)
        const mult = allMult[isSrc ? 'outgoingTo' : 'incomingFrom']
        const other = isSrc ? 'target' : 'source'
        const me = isSrc ? 'source' : 'target'
        const neighborType = this.getVertexType(edge[other])
        const neighbors = vertex.edges.filter(
          e =>
            this.getVertexType(e[other]) === neighborType &&
            e[me].id === vertex.id
        )
        const occurences = neighbors.length
        if (occurences > mult[neighborType]) {
          throw new Error(
            `Failed to validate, max ${mult[neighborType]}, found ${occurences}`
          )
        }
      }
    }
  }
}
</script>

<style scoped>
#graphContainer {
  border: 1px solid black;
  background-color: #ededed;
}

#graph {
  overflow: auto;
  height: 55vh;
  width: 80vw;
  cursor: default;
}

#toolbar {
  height: auto;
  border-radius: 10px;
  padding: 10px;
  border: 1px solid black;
  vertical-align: middle;
  width: fit-content;
  margin: 0 auto;
}

#xml {
  height: 55vh;
  width: 684px;
  display: none;
  border-style: none;
}

#splash {
  padding-top: 27vh;
}

.source-ipt {
  float: right;
  padding-right: 1.5em;
}

.table {
  margin-left: auto;
  margin-right: auto;
}
</style>
